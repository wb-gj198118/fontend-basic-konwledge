## 前言

HTML 语言在前端开发领域是非常基础且简单的设计型语言，可以不夸张的说，无论是前端小白还是非前端工程师，涉及到编程领域的人几乎没有不会这门语言的。HTML 的语言特点是通过结构化的标记节点来描述页面结构，在浏览器中运行该代码时便会形成网页的基本布局，那么 HTML 的标记节点是如何被浏览器识别并画到网页中的呢？

## 网页渲染的流程

浏览器渲染引擎工作流程都差不多，大致分为 5 步，**创建 DOM 树——创建 StyleRules——创建 Render 树——布局Layout（重排）——绘制 Painting（重绘）**

第一步，用 HTML 分析器，分析 HTML 元素，**构建一颗 DOM 树**(标记化和树构建)。

第二步，用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。

第三步，将 DOM 树和样式表，关联起来，构建一颗 Render 树(这一过程又称为 Attachment)。每个 DOM 节点都有**attach 方法，接受样式信息**，返回一个render对象(又名renderer)。这些 render 对象最终会被构建成一颗 Render 树。

第四步，有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。

第五步，Render 树和节点显示坐标都有了，就调用每个节点 **paint 方法，把它们绘制**出来。

**DOM 树的构建是文档加载完成开始的？**构建 DOM 树是一个渐进过程，为达到更好用户体验，渲染引擎会尽快将内容显示在屏幕上。**它不必**等到整个 HTML 文档解析完毕之后才开始构建 render 树和布局。

**Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？**这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一遍解析，一遍渲染的工作现象。

**CSS 的解析是从右往左逆向解析的**(从 DOM 树的下－上解析比上－下解析效率高)，**嵌套标签越多，解析越慢。**

![](https://pic4.zhimg.com/v2-24c7d689c542f0b7e889cb983e1e5bef_r.jpg)

## 今天只研究 DOM 树！

上面的内容简单的介绍了浏览器解释并渲染网页的整个流程，这个流程相信读者也并不会感到陌生，为了更清晰更深入的认识看似简单的 HTML，本次以手写 HTML 解释器的方式将浏览器的神秘面纱揭开。

### 简单的 HTML 语言蕴含的知识

首先通过一个简单的 HTML 结构重温一下 HTML 语言：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>&lt;div id="d"&gt;</td></tr><tr><td></td><td>你好</td></tr><tr><td></td><td>&lt;button class="btn"&gt;</td></tr><tr><td></td><td>按钮</td></tr><tr><td></td><td>&lt;/button&gt;</td></tr><tr><td></td><td>&lt;/div&gt;</td></tr></tbody></table>

上面便是日常生活中大家常写的一段基本 HTML 语法片段，之所以使用标记节点的方式构建页面是因为其天然的嵌套结构可以很好的描述页面中各节点的关系。这样无论是人类还是计算机都可以在不查看显示结果的前提下，很容易的通过阅读该代码了解节点的组成和关系。

### 浏览器眼中的 HTML 是什么样的？

对于开发者来说，通过简单的阅读代码便可以读取到代码中蕴含的信息，但是计算机并不是人类，计算机本身并没有语义识别的能力和自我思考的能力，他们只会机械的完成开发者发出的命令，所以在计算机眼中阅读的 HTML 代码是什么？

答案就是：DOM 树！

所以在计算机的眼里，上面写的代码大概是这样的：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>[</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>type:'node',</td></tr><tr><td></td><td>tag:'div',</td></tr><tr><td></td><td>attrs:{</td></tr><tr><td></td><td>id:'a'</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>children:[</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>type:'text',</td></tr><tr><td></td><td>value:'你好'</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>type:'node',</td></tr><tr><td></td><td>tag:'button',</td></tr><tr><td></td><td>attrs:{</td></tr><tr><td></td><td>class:'btn'</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>children:[</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>type:'text',</td></tr><tr><td></td><td>value:'按钮'</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>]</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>]</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>]</td></tr></tbody></table>

为什么计算机要把很清晰的标记节点变成结构化的对象呢？HTML 标记语言要更简洁更清晰啊？原因非常简单，因为浏览器在运行代码时必须结合系统的堆栈空间来保存关键数据的信息，而 HTML 的标记结构在计算机的眼中仅仅是这一段字符串而已，并没有其中蕴含的信息，计算机想要知道这段脚本代表的真实含义必须将节点中的关键信息提取出来，那么就需要将提取到的信息分别保存在 heap（堆）内存中，这样才能保证在绘制网页时有条理的一个一个的进行绘制。那么问题来了，浏览器是如何把一段标记语言变成 DOM 树的呢？

## 揭秘HTML解释器

首先要清楚一件事，浏览器在接收到开发者提交的 HTML 代码时，到他面前的代码本质上是这样的：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>//没错，浏览器得到的仅仅是一段排列组合的字符而已</td></tr><tr><td></td><td>let code = `</td></tr><tr><td></td><td>&lt;div id="root" class="abc" name="aaa" &gt;</td></tr><tr><td></td><td>left</td></tr><tr><td></td><td>&lt;span&gt;</td></tr><tr><td></td><td>222</td></tr><tr><td></td><td>&lt;button&gt;</td></tr><tr><td></td><td>123</td></tr><tr><td></td><td>&lt;/button&gt;&lt;/span&gt;&lt;img src="ddd" /&gt;</td></tr><tr><td></td><td>right</td></tr><tr><td></td><td>&lt;/div&gt;</td></tr><tr><td></td><td>top</td></tr><tr><td></td><td>&lt;div id="d"&gt;&lt;button id="btn"&gt; xxx&lt;/button&gt;&lt;div&gt;&lt;span&gt;</td></tr><tr><td></td><td>xxx</td></tr><tr><td></td><td>&lt;button&gt;</td></tr><tr><td></td><td>yyy</td></tr><tr><td></td><td>123</td></tr><tr><td></td><td>&lt;button id="123" &gt;</td></tr><tr><td></td><td>nnn</td></tr><tr><td></td><td>&lt;img/&gt;&lt;/button&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;br/&gt;</td></tr><tr><td></td><td>top-right</td></tr><tr><td></td><td>top-left</td></tr><tr><td></td><td>`</td></tr></tbody></table>

这样的字符组合对于浏览器来说，有缩进和无缩进没有任何意义，因为字符本身不带有任何的特殊能力。所以浏览器接下来的工作就变得枯燥且乏味了，也就是大学生活中计算机专业同学所必修的课程之一——编译原理。

### 想办法把字符代码搞成对象

想要从这段字符中提取关键信息的话，必定逃不掉的知识就是编译原理，这里涉及到几个关键的知识点：

-   **词法分析（lexical analysis）**：进行词法分析的程序或者函数叫作词法分析器（Lexical analyzer，简称 Lexer），也叫扫描器（Scanner，例如typescript源码中的 scanner.ts），字符流转换成对应的 Token 流。
-   **tokenize**：tokenize 就是按照一定的规则，例如 token令牌（通常代表关键字，变量名，语法符号等），将代码分割为一个个的“串”，也就是语法单元）。涉及到词法解析的时候，常会用到 tokennize。
-   **语法分析（parse analysis）**：是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成语法树，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确。源程序的结构由上下文无关文法描述。

理论上讲非常的抽象，实际上代码的编译过程翻译成人话就是，先从这一团杂乱的字符中提取关键信息，其中包含：关键字、单词、符号和分隔符等等，并将这些关键信息整理成一张线性表。得到线性表后的计算机程序会根据得到的关键词和符号等结构将程序整理成有规则的结构，然后将关键信息放在置顶的关键位置，这个结果通常是一棵树也被称为AST（abstract syntax tree）抽象语法树。这个过程进行完毕浏览器就成功的将 HTML 转换成了 DOM 树。

### 说干就干，词法分析器来了

本文通过类似 AST 的方式解决 HTML 到 DOM 的完成过程，但生成的结果并不会与 AST 一致，由于 HTML 为设计型语言，并不存在编程语言的特性，所以词法分析阶段与其他的语言识别器类似，但后续的语法分析则要简单很多。那么如何实现一个词法分析器呢？

对于浏览器来说，当它阅读开发者提交的 HTML 代码时实际是按照这样的步骤阅读的：

![](https://pic1.zhimg.com/v2-bdd1706185524ddebbe7f6719b13b7ec_r.jpg)

如上图，浏览器只能一个字符一个字符进行代码的读取，那么这样阅读之后得到的岂不是一大堆的单个字符？和我们的预期差距非常的大啊！所以接下来参考下图继续看浏览器读取代码的骚操作。

![](https://pic2.zhimg.com/v2-5f88bbba5d01eff92c46f5dff11baba9_r.jpg)

如上图，也就是说浏览器在阅读字符时也并不是完全不思考，当其阅读到符号内容时，会一个一个的记录单独的符号，而读取到的内容为字符时，若连续阅读的都是字符浏览器会记录从头到尾的所有字符，一旦下一个内容得到的是非字符元素时，浏览器便会收录一个关键字，这样便实现了词法分析器。

### 用 JavaScript 做一个词法分析器吧

实现词法分析器的实际算法前，需要准备三个变量来存放一些关键内容

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>//符号（这里用了一个拼音缩写见谅）</td></tr><tr><td></td><td>let fh = ['&lt;','&gt;','/','\'','\"','=']</td></tr><tr><td></td><td>//分隔符</td></tr><tr><td></td><td>let space = ['\n','\r','\t',' ']</td></tr><tr><td></td><td>//系统保留字</td></tr><tr><td></td><td>let letters = ['div','button','span','img','br','h1','h2']</td></tr></tbody></table>

需要有这些基础内容，在读取字符时才能知道读取到的内容属于哪个范畴方便记录。接下来便是词法分析器的代码实现：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>//通过字符识别scanner扫描状态</td></tr><tr><td></td><td>function getStatus(letter){</td></tr><tr><td></td><td>if(space.includes(letter)){</td></tr><tr><td></td><td>//扫描到无效字符或分隔符状态</td></tr><tr><td></td><td>return 0</td></tr><tr><td></td><td>}else if(fh.includes(letter)){</td></tr><tr><td></td><td>// 扫描到符号状态</td></tr><tr><td></td><td>return 1</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>// 扫描到字母状态</td></tr><tr><td></td><td>return 2</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//词法分析器</td></tr><tr><td></td><td>function makeTokens(code){</td></tr><tr><td></td><td>let index = 0//扫描索引</td></tr><tr><td></td><td>let status = 0//扫描状态</td></tr><tr><td></td><td>let lastStatus = 0//上一个字符状态</td></tr><tr><td></td><td>let nextStatus = 0//下一个字符状态</td></tr><tr><td></td><td>let keyword = ''//扫描到的关键字</td></tr><tr><td></td><td>//定义本次字符，上一个字符，下一个字符</td></tr><tr><td></td><td>let letter,lastLetter,nextLetter = ''</td></tr><tr><td></td><td>//词法分析结果</td></tr><tr><td></td><td>let tokens = []</td></tr><tr><td></td><td>//开启遍历</td></tr><tr><td></td><td>while(index&lt;code.length){</td></tr><tr><td></td><td>//获取本次字符</td></tr><tr><td></td><td>letter = code[index]</td></tr><tr><td></td><td>//获取上一个字符</td></tr><tr><td></td><td>if(index&gt;0){</td></tr><tr><td></td><td>lastLetter = code[index-1]</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//获取下一个字符</td></tr><tr><td></td><td>if(index&lt;code.length-1){</td></tr><tr><td></td><td>nextLetter = code[index+1]</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//获取本次状态</td></tr><tr><td></td><td>status = getStatus(letter)</td></tr><tr><td></td><td>//获取上一次状态</td></tr><tr><td></td><td>lastStatus = getStatus(lastLetter)</td></tr><tr><td></td><td>//获取下一次状态</td></tr><tr><td></td><td>nextStatus = getStatus(nextLetter)</td></tr><tr><td></td><td>//分状态判断</td></tr><tr><td></td><td>switch (status){</td></tr><tr><td></td><td>case 1://扫描到符号时直接装进tokens</td></tr><tr><td></td><td>keyword = letter</td></tr><tr><td></td><td>tokens.push({</td></tr><tr><td></td><td>type:'fh',</td></tr><tr><td></td><td>keyword</td></tr><tr><td></td><td>})</td></tr><tr><td></td><td>keyword = ''</td></tr><tr><td></td><td>break;</td></tr><tr><td></td><td>case 2://扫描到非符号字符时</td></tr><tr><td></td><td>//将字符连接成关键字</td></tr><tr><td></td><td>keyword+=letter</td></tr><tr><td></td><td>//若下一次扫描到的不是普通字符</td></tr><tr><td></td><td>if(nextStatus!=2){</td></tr><tr><td></td><td>//判断是否为系统保留字</td></tr><tr><td></td><td>if(letters.includes(keyword)){</td></tr><tr><td></td><td>//封装系统保留字</td></tr><tr><td></td><td>tokens.push({</td></tr><tr><td></td><td>type:'word',</td></tr><tr><td></td><td>keyword</td></tr><tr><td></td><td>})</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//若不是系统保留字则封装为其他关键字</td></tr><tr><td></td><td>tokens.push({</td></tr><tr><td></td><td>type:'other',</td></tr><tr><td></td><td>keyword</td></tr><tr><td></td><td>})</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//重置关键字防止影响下次扫描</td></tr><tr><td></td><td>keyword=''</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>break;</td></tr><tr><td></td><td>default:</td></tr><tr><td></td><td>break;</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//指向下一个字符</td></tr><tr><td></td><td>index++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//返回词法分析结果</td></tr><tr><td></td><td>return tokens</td></tr><tr><td></td><td>}</td></tr></tbody></table>

接下来准备一段代码，测试一下词法分析器的结果：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>let code = `</td></tr><tr><td></td><td>&lt;div id="d"&gt;</td></tr><tr><td></td><td>hello</td></tr><tr><td></td><td>&lt;button class="btn"&gt;你好&lt;/button&gt;&lt;/div&gt;</td></tr><tr><td></td><td>`</td></tr><tr><td></td><td>let tokens = makeTokens(code)</td></tr><tr><td></td><td>console.log(tokens)</td></tr></tbody></table>

运行代码后，会得到一个很大的 JSON 数组，该数组大致如下：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>[</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&lt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "word",</td></tr><tr><td></td><td>"keyword": "div"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "other",</td></tr><tr><td></td><td>"keyword": "id"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "="</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "\""</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "other",</td></tr><tr><td></td><td>"keyword": "d"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "\""</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&gt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "other",</td></tr><tr><td></td><td>"keyword": "hello"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&lt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "word",</td></tr><tr><td></td><td>"keyword": "button"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "other",</td></tr><tr><td></td><td>"keyword": "class"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "="</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "\""</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "other",</td></tr><tr><td></td><td>"keyword": "btn"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "\""</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&gt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "other",</td></tr><tr><td></td><td>"keyword": "你好"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&lt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "/"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "word",</td></tr><tr><td></td><td>"keyword": "button"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&gt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&lt;"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "/"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "word",</td></tr><tr><td></td><td>"keyword": "div"</td></tr><tr><td></td><td>},</td></tr><tr><td></td><td>{</td></tr><tr><td></td><td>"type": "fh",</td></tr><tr><td></td><td>"keyword": "&gt;"</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>]</td></tr></tbody></table>

通过阅读该结构发现，词法分析器的作用就是将不具备关键信息点的完整字符串的关键信息按类别提取并保存到线性表中。

### 胜利就在前方，DOM 树来了

有了词法分析器构造的线性表之后，下一步的任务就是通过阅读线性表识别出 HTML 应用的节点层级关系并将其填装到一个对象中，此步骤涉及到部分基础算法（遍历树的深度优先算法以及其他基础算法思想），用文字描述很难表现出作者的诚意，所以完整的 DOM 树构建代码附上(内附完整注释，代码编写匆忙，有不严谨的地方望见谅)：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>/**</td></tr><tr><td></td><td>* 根据叶子节点id和根对象获取叶子节点的上一个节点（表示其前一个兄弟节点，或其直接父亲节点）</td></tr><tr><td></td><td>* 采用深度优先算法进行树的遍历</td></tr><tr><td></td><td>* @param {Object} nodeIndex 节点的index</td></tr><tr><td></td><td>* @param {Object} deep 节点的deep</td></tr><tr><td></td><td>* @param {Object} doc DOM树对象</td></tr><tr><td></td><td>* @param {Object} obj 节点对象（保留对象）</td></tr><tr><td></td><td>*/</td></tr><tr><td></td><td>function getObjByIndex(nodeIndex,deep,doc,obj){</td></tr><tr><td></td><td>//目标节点对象</td></tr><tr><td></td><td>let target = {}</td></tr><tr><td></td><td>let index = 0 //起始索引</td></tr><tr><td></td><td>let tree = doc //初始化树对象</td></tr><tr><td></td><td>while(index&lt;tree.length){</td></tr><tr><td></td><td>// debugger</td></tr><tr><td></td><td>//获取跟节点的每个叶子节点</td></tr><tr><td></td><td>let item = tree[index]</td></tr><tr><td></td><td>//若传入节点的index匹配成功</td></tr><tr><td></td><td>if(nodeIndex == item.index){</td></tr><tr><td></td><td>//记录返回数据</td></tr><tr><td></td><td>target = item</td></tr><tr><td></td><td>//若传入节点的深度低于目标节点，需要逐层找到相同层的节点</td></tr><tr><td></td><td>while(deep&lt;target.deep){</td></tr><tr><td></td><td>target = target.parentNode</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>return target</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若节点具有子代叶子节点</td></tr><tr><td></td><td>if(item.children){</td></tr><tr><td></td><td>//重置需要遍历内部叶子节点</td></tr><tr><td></td><td>let col = 0</td></tr><tr><td></td><td>//遍历根节点层的叶子节点</td></tr><tr><td></td><td>while(col&lt;item.children.length){</td></tr><tr><td></td><td>// console.log(index,i)</td></tr><tr><td></td><td>//逐个获取叶子节点</td></tr><tr><td></td><td>let obj = item.children[col]</td></tr><tr><td></td><td>// 若内层叶子节点匹配成功</td></tr><tr><td></td><td>if(nodeIndex == obj.index){</td></tr><tr><td></td><td>target = obj</td></tr><tr><td></td><td>while(deep&lt;target.deep){</td></tr><tr><td></td><td>target = target.parentNode</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>return target</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若子代叶子节点仍然有子元素</td></tr><tr><td></td><td>if(obj.children){</td></tr><tr><td></td><td>//将遍历条件切换为该节点并重置遍历索引</td></tr><tr><td></td><td>item = obj</td></tr><tr><td></td><td>col = 0</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//若该节点没有子代叶子节点，且当前节点有下一个节点</td></tr><tr><td></td><td>if(item.children[col+1]){</td></tr><tr><td></td><td>//则直接去下一个节点</td></tr><tr><td></td><td>col++</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//若该节点无子代节点并且无下一个节点代表当前深度遍历到本条线路的最后一个</td></tr><tr><td></td><td>//获取当前item的父节点</td></tr><tr><td></td><td>let parent = item.parentNode</td></tr><tr><td></td><td>//判断当前遍历层是否为父节点的最后一个子节点，如果有则返回上一层，知道当前节点不是同层最后一个节点</td></tr><tr><td></td><td>while(parent.children&amp;&amp;parent.children.indexOf(item) == parent.children.length-1){</td></tr><tr><td></td><td>//向上跳跃</td></tr><tr><td></td><td>item = parent</td></tr><tr><td></td><td>parent = parent.parentNode</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若当前父节点没有跳回最上层</td></tr><tr><td></td><td>if(parent.children){</td></tr><tr><td></td><td>//获取当前item节点所在序号</td></tr><tr><td></td><td>col = parent.children.indexOf(item)</td></tr><tr><td></td><td>//将item上跳触发新路径的遍历</td></tr><tr><td></td><td>item = parent</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//若回到跟节点则代表大节点遍历完毕，跳出内层while循环</td></tr><tr><td></td><td>col = item.length</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//增加索引</td></tr><tr><td></td><td>col++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//增加单层索引</td></tr><tr><td></td><td>index++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>return target</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//构建节点对象树的实际工具函数</td></tr><tr><td></td><td>/**</td></tr><tr><td></td><td>* 根据节点信息构建节点对象并插入到DOM树中</td></tr><tr><td></td><td>* @param {Object} deep 节点深度</td></tr><tr><td></td><td>* @param {Object} leafIndex 节点序号（id）</td></tr><tr><td></td><td>* @param {Object} doc DOM树对象</td></tr><tr><td></td><td>* @param {Object} begin 扫描起点</td></tr><tr><td></td><td>* @param {Object} end 扫描终点</td></tr><tr><td></td><td>* @param {Object} status 扫描状态 0为进入节点外部，1为进入起始标签，2为进入终止标签</td></tr><tr><td></td><td>* @param {Object} nodeStatus 节点结构 1单标签，2双标签</td></tr><tr><td></td><td>*/</td></tr><tr><td></td><td>function makeObj(deep,leafIndex,doc,begin,end,status,nodeStatus){</td></tr><tr><td></td><td></td></tr><tr><td></td><td>let tag = ''</td></tr><tr><td></td><td>//当闭合标签结束时status为1时代表标签头信息,防止误将&lt;/xxx&gt;等结束符号记录为有效节点</td></tr><tr><td></td><td>if(status == 1){</td></tr><tr><td></td><td>//定义属性字符串</td></tr><tr><td></td><td>let attrStr = ''</td></tr><tr><td></td><td>//遍历扫描范围</td></tr><tr><td></td><td>let attrStatus = 0</td></tr><tr><td></td><td>while(begin&lt;=end){</td></tr><tr><td></td><td>​</td></tr><tr><td></td><td>//获取关键字</td></tr><tr><td></td><td>let item = tokens[begin]</td></tr><tr><td></td><td>let lastItem = tokens[begin-1]</td></tr><tr><td></td><td>//当关键字类型为word时代表当前标签名称</td></tr><tr><td></td><td>if(item.type == 'word'){</td></tr><tr><td></td><td>tag = item.keyword</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//筛选属性数据并拼接到属性字符串中</td></tr><tr><td></td><td>if((item.type == 'fh' || item.type == 'other') &amp;&amp; item.keyword!='&lt;' &amp;&amp; item.keyword!='&gt;' &amp;&amp; item.keyword!='/'){</td></tr><tr><td></td><td>attrStr+=item.keyword</td></tr><tr><td></td><td>if(item.keyword=='\''&amp;&amp;lastItem.keyword != '='){</td></tr><tr><td></td><td>attrStr += ';'</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>if(item.keyword=='\"'&amp;&amp;lastItem.keyword != '='){</td></tr><tr><td></td><td>attrStr += ';'</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//扫描递增</td></tr><tr><td></td><td>begin++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//定义节点对象</td></tr><tr><td></td><td>let obj = {</td></tr><tr><td></td><td>type:'node',//节点类型</td></tr><tr><td></td><td>deep,//节点深度</td></tr><tr><td></td><td>index:leafIndex,//节点id</td></tr><tr><td></td><td>tag,//标签名</td></tr><tr><td></td><td>attrs:{},//属性</td></tr><tr><td></td><td>nodeStatus</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//根据叶子节点id获取他前一个节点的信息</td></tr><tr><td></td><td>let target = getObjByIndex(leafIndex-1,deep,doc,obj)</td></tr><tr><td></td><td>//封装节点属性</td></tr><tr><td></td><td>attrStr.replace(/(\'|\")/g,'').split(';').forEach(item =&gt; {</td></tr><tr><td></td><td>if(item.trim().length&gt;0){</td></tr><tr><td></td><td>let [key,value] = item.split('=')</td></tr><tr><td></td><td>obj.attrs[key] = value</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>})</td></tr><tr><td></td><td>//当上一个节点为空时设置跟节点</td></tr><tr><td></td><td>if(Object.keys(target).length == 0){</td></tr><tr><td></td><td>obj.parentNode = doc</td></tr><tr><td></td><td>doc.push(obj)</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//当上一个节点有值时，判断当前节点是否是上一个节点的子节点</td></tr><tr><td></td><td>if(deep&gt;target.deep){</td></tr><tr><td></td><td>obj.parentNode = target</td></tr><tr><td></td><td>//设置子节点</td></tr><tr><td></td><td>if(target.children){</td></tr><tr><td></td><td>target.children.push(obj)</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>target.children = [obj]</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//当深度相同时获取上一个节点的父节点并插入兄弟对象</td></tr><tr><td></td><td>}else if(deep == target.deep){</td></tr><tr><td></td><td>obj.parentNode = target.parentNode</td></tr><tr><td></td><td>if(target.parentNode.children){</td></tr><tr><td></td><td>target.parentNode.children.push(obj)</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>doc.push(obj)</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>/**</td></tr><tr><td></td><td>* 根据词法分析结果将线性表整理成树</td></tr><tr><td></td><td>* @param {Object} tokens</td></tr><tr><td></td><td>*/</td></tr><tr><td></td><td>function makeTokensToTree(tokens){</td></tr><tr><td></td><td>let i = 0 //索引</td></tr><tr><td></td><td>let status = 0 //状态 0代表进入标签外节点 1代表起始节点 2代表结束节点</td></tr><tr><td></td><td>let nextKeyword //下一个关键字</td></tr><tr><td></td><td>let lastKeyword</td></tr><tr><td></td><td>let nextType //下一个token类型</td></tr><tr><td></td><td>let lastType</td></tr><tr><td></td><td>let doc = [] //文档对象</td></tr><tr><td></td><td>let deep = 0 //节点深度</td></tr><tr><td></td><td>let leafIndex = 0 //叶子节点id</td></tr><tr><td></td><td>let begin = 0 //扫描起始点</td></tr><tr><td></td><td>let end = 0 //扫描重点</td></tr><tr><td></td><td>//遍历tokens列表</td></tr><tr><td></td><td>while(i&lt;tokens.length){</td></tr><tr><td></td><td>//获取当次节点对象</td></tr><tr><td></td><td>let { type,keyword } = tokens[i]</td></tr><tr><td></td><td>//获取下一个节点（如果有的话）</td></tr><tr><td></td><td>if(i&lt;tokens.length-1){</td></tr><tr><td></td><td>nextKeyword = tokens[i+1].keyword</td></tr><tr><td></td><td>nextType = tokens[i+1].type</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>if(i&gt;0){</td></tr><tr><td></td><td>lastKeyword = tokens[i-1].keyword</td></tr><tr><td></td><td>lastType = tokens[i-1].type</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//如果是符号节点</td></tr><tr><td></td><td>if(type == 'fh'){</td></tr><tr><td></td><td>//当符号以&lt;开头代表起始标签</td></tr><tr><td></td><td>if(keyword == '&lt;'&amp;&amp; nextKeyword!= '/'){</td></tr><tr><td></td><td>//设置状态为1</td></tr><tr><td></td><td>status = 1</td></tr><tr><td></td><td>//每次起始时增加深度以便记录连续嵌套标签的深度</td></tr><tr><td></td><td>deep++</td></tr><tr><td></td><td>//设置开始节点的扫描起点</td></tr><tr><td></td><td>begin = i</td></tr><tr><td></td><td>//递增叶子节点id</td></tr><tr><td></td><td>leafIndex++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//当符号以&lt;/开头代表结束标签</td></tr><tr><td></td><td>if(keyword == '&lt;'&amp;&amp; nextKeyword == '/'){</td></tr><tr><td></td><td>// 设置状态为2代表进入结束节点</td></tr><tr><td></td><td>status = 2</td></tr><tr><td></td><td>//设置结束节点的扫描起点</td></tr><tr><td></td><td>begin = i</td></tr><tr><td></td><td>//节点结束后深度-1保证同层节点深度相同</td></tr><tr><td></td><td>deep--</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//当符号以/&gt;结束时代表自结束标签的结束</td></tr><tr><td></td><td>if(keyword == '&gt;'&amp;&amp; lastKeyword == '/'){</td></tr><tr><td></td><td>//设置扫描终点</td></tr><tr><td></td><td>end = i</td></tr><tr><td></td><td>//制作单标签对象结构</td></tr><tr><td></td><td>makeObj(deep,leafIndex,doc,begin,end,status,1)</td></tr><tr><td></td><td>//深度上浮保证下一个节点为兄弟节点</td></tr><tr><td></td><td>deep--</td></tr><tr><td></td><td>//设置状态为进入节点外</td></tr><tr><td></td><td>status = 0</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//当符号扫描到&gt;时代表一个闭合标签结束</td></tr><tr><td></td><td>if(keyword == '&gt;'&amp;&amp; lastKeyword != '/'){</td></tr><tr><td></td><td>// 记录扫描结束节点</td></tr><tr><td></td><td>end = i</td></tr><tr><td></td><td>makeObj(deep,leafIndex,doc,begin,end,status,2)</td></tr><tr><td></td><td>//扫描结束后改变状态</td></tr><tr><td></td><td>status = 0</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//当扫描到节点外部时，处理文本节点</td></tr><tr><td></td><td>if(status == 0){</td></tr><tr><td></td><td>let obj = {</td></tr><tr><td></td><td>type:'text',</td></tr><tr><td></td><td>value:keyword,</td></tr><tr><td></td><td>// parentDeep:deep,</td></tr><tr><td></td><td>deep:deep+1,</td></tr><tr><td></td><td>// parentIndex:leafIndex,</td></tr><tr><td></td><td>index:leafIndex+1</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>let target = getObjByIndex(leafIndex,deep,doc,obj)</td></tr><tr><td></td><td>obj.parentNode = target</td></tr><tr><td></td><td>if(target.children){</td></tr><tr><td></td><td>target.children.push(obj)</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>if(target == doc){</td></tr><tr><td></td><td>target.push(obj)</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>target.children = [obj]</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>leafIndex++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>i++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>return doc</td></tr><tr><td></td><td>}</td></tr></tbody></table>

  

小贴士：

这里所有的树的遍历均采用 while 循环的方式处理主要目的是防止递归函数潜在的执行栈溢出风险。

### 试试我们的成果吧

在语法分析器和词法分析器的组合下，将下面的 HTML 结构整理成 DOM 树的形态：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>let code = `</td></tr><tr><td></td><td>&lt;div id="d"&gt;</td></tr><tr><td></td><td>hello</td></tr><tr><td></td><td>&lt;button class="btn"&gt;你好&lt;/button&gt;&lt;img src="url"/&gt;&lt;/div&gt;</td></tr><tr><td></td><td>一段意外的文本 &lt;br/&gt;</td></tr><tr><td></td><td>&lt;div id="root"&gt;&lt;span&gt;&lt;h1&gt;我是标题&lt;/h1&gt;&lt;button&gt;点我&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;</td></tr><tr><td></td><td>`</td></tr><tr><td></td><td>let tokens = makeTokens(code)</td></tr><tr><td></td><td>let tree = makeTokensToTree(tokens)</td></tr><tr><td></td><td>console.log(tree)</td></tr></tbody></table>

不出意外的话接下来控制台中会得到如下的结果：

![](https://pic3.zhimg.com/v2-bf5274ba9491841ee1e345ea71da826a_r.jpg)

看到这个结果，是不是才意识到，原来，浏览器其实并不认识 HTML，一切的代码都是一段字符描述而已，程序执行引擎在运行程序时做了大量的基础工作，才让开发者编写的带有逻辑语法和关键字的编程语言真正的跑起来，这时是不是该致敬一下语法编译器的开发者们！！

## 作业（反向生成 HTML）

这个简单吧～既然 HTML 语法解释器实现起来稍微复杂一点点，那么若将生成的 DOM 对象反向变回 HTML 代码是不是就简单很多了？

提前公布答案吧：

<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><td></td><td>/**</td></tr><tr><td></td><td>* DOM结构转HTML代码</td></tr><tr><td></td><td>*</td></tr><tr><td></td><td>* @param {Object} tree DOM树对象</td></tr><tr><td></td><td>*/</td></tr><tr><td></td><td>function DOM2HTML(tree){</td></tr><tr><td></td><td>// console.log(tree)</td></tr><tr><td></td><td>//总起始索引</td></tr><tr><td></td><td>let index = 0</td></tr><tr><td></td><td>//生成的HTML代码</td></tr><tr><td></td><td>let str = ''</td></tr><tr><td></td><td>//跳出条件</td></tr><tr><td></td><td>while(index&lt;tree.length){</td></tr><tr><td></td><td>// debugger</td></tr><tr><td></td><td>//获取所有根节点</td></tr><tr><td></td><td>let item = tree[index]</td></tr><tr><td></td><td>//从根节点中提取不同结构的节点</td></tr><tr><td></td><td>if(item.type== 'node'){</td></tr><tr><td></td><td>if(item.nodeStatus == 2){</td></tr><tr><td></td><td>str+=makeSpace(item.deep)+`&lt;${item.tag} ${makeAttrs(item)} &gt;\n`</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>str+=makeSpace(item.deep)+`&lt;${item.tag} ${makeAttrs(item)} /&gt;\n`</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}else if(item.type == 'text'){</td></tr><tr><td></td><td>str+=makeSpace(item.deep)+item.value+'\n'</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若节点存在子元素</td></tr><tr><td></td><td>if(item.children){</td></tr><tr><td></td><td>//遍历每一个根节点的子树</td></tr><tr><td></td><td>let col = 0</td></tr><tr><td></td><td>//跳出条件</td></tr><tr><td></td><td>while(col&lt;item.children.length){</td></tr><tr><td></td><td>//获取每一个子节点</td></tr><tr><td></td><td>let obj = item.children[col]</td></tr><tr><td></td><td>//根据子节点生成头部标签和内容</td></tr><tr><td></td><td>if(obj.type== 'node'){</td></tr><tr><td></td><td>if(obj.nodeStatus == 2){</td></tr><tr><td></td><td>str+=makeSpace(obj.deep)+`&lt;${obj.tag} ${makeAttrs(obj)} &gt;\n`</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>str+=makeSpace(obj.deep)+`&lt;${obj.tag} ${makeAttrs(obj)}/&gt;\n`</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}else if(obj.type == 'text'){</td></tr><tr><td></td><td>str+=makeSpace(obj.deep)+obj.value+'\n'</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若子节点存在子代节点</td></tr><tr><td></td><td>if(obj.children){</td></tr><tr><td></td><td>//进入子节点并重置序号</td></tr><tr><td></td><td>item = obj</td></tr><tr><td></td><td>col = 0</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//若子节点不存在任何叶子节点，并且其并不是最后一个节点</td></tr><tr><td></td><td>if(item.children[col+1]){</td></tr><tr><td></td><td>//若子节点为双标签则生成闭合结尾</td></tr><tr><td></td><td>if(obj.type== 'node'&amp;&amp;obj.nodeStatus == 2){</td></tr><tr><td></td><td>// console.log(`&lt;/${obj.tag}&gt;`)</td></tr><tr><td></td><td>str+=makeSpace(obj.deep)+`&lt;/${obj.tag}&gt;\n`</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//向后移动指针</td></tr><tr><td></td><td>col++</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//获取当前节点层的父节点</td></tr><tr><td></td><td>let parent = item.parentNode</td></tr><tr><td></td><td>//若子节点不存在下一个邻居节点，判断子节点是否为当前层最后一个节点</td></tr><tr><td></td><td>while(parent.children&amp;&amp;parent.children.indexOf(item) == parent.children.length-1){</td></tr><tr><td></td><td>//若为最后一个节点则生成闭合结尾</td></tr><tr><td></td><td>if(item.nodeStatus == 2){</td></tr><tr><td></td><td>str+=makeSpace(item.deep)+`&lt;/${item.tag}&gt;\n`</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若节点为最后一个节点则逐层向上，直到节点不是最后一个节点</td></tr><tr><td></td><td>item = parent</td></tr><tr><td></td><td>parent = parent.parentNode</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若节点有子代元素则继续遍历</td></tr><tr><td></td><td>if(parent.children){</td></tr><tr><td></td><td>//若节点为双标签则生成闭合节点</td></tr><tr><td></td><td>if(item.nodeStatus == 2){</td></tr><tr><td></td><td>str+=makeSpace(item.deep)+`&lt;/${item.tag}&gt;\n`</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//若该节点层仍有后续兄弟节点</td></tr><tr><td></td><td>col = parent.children.indexOf(item)</td></tr><tr><td></td><td>//向上跳</td></tr><tr><td></td><td>item = parent</td></tr><tr><td></td><td>}else{</td></tr><tr><td></td><td>//若parent没有children代表已经跳到根节点则退出循环</td></tr><tr><td></td><td>col = item.length</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>col++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>​</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>//生成父节点的闭合结尾标签</td></tr><tr><td></td><td>if(item.type== 'node'&amp;&amp; item.nodeStatus == 2){</td></tr><tr><td></td><td>str+=makeSpace(item.deep)+`&lt;/${item.tag}&gt;\n`</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>index++</td></tr><tr><td></td><td>}</td></tr><tr><td></td><td>return str</td></tr><tr><td></td><td>}</td></tr></tbody></table>

这段代码便是根据上面的解释器构造的 DOM 树反向生成 HTML 的实现（附效果图）

![](https://pic3.zhimg.com/v2-1830cb92f398b95404ee1c613ac7cc6a_r.jpg)